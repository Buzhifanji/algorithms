---
icon: notebook
title: 分析算法
date: 2022-08-26
description: ''
category:
  - 算法基础
tag:
  - 分析算法
---

## 介绍

分析算法的结果意味着预测算法需要的资源，例如内存、通信宽带、计算机硬件等等。但是通常我们通过**计算时间**来度量算法。为了分析算法的运行时间，我们需要一个实现技术的模型，包括用于描述所用资源及其代价的模型。这里假定通用的单处理器计算模型RAM(random-access machine)作为实现技术，在RAM模型中，指令一条一条地执行，没有并发操作。

::: tip 说明
通用的单处理器计算模型RAM在这里不指代计算机中的高速缓存或虚拟内存等，这些现代存储技术可能对于真实计算机上运行的真实程序影响重大。
:::

RAM模型包含计算机常见的指令：算术指令（`+、-、*、/、%`等）、数据移动指令（存储、复制、装入等）、控制指令（条件、子程序调用与返回）等，**每条这样的指令所需的时间都为常量**。RAM模型中存在一些灰色区域（包含了一些未列出的指令），例如计算 $x^y$ 或者相对典型的 $2^k$，计算可能需要若干条指令才能完成，而计算 $2^k$ 则相对简单一些，只需要将数据左移 `k` 位即可，当足够小的情况下，可以将看作一个  $2^k$ 常量时间的操作。

采用RAM模型分析算法的运行时间，需要的数学工具可能包括组合学、概率论、代数技巧以及识别公式中最有意义的项。

::: tip 说明
识别公式中最有意义的项，个人理解为识别公式中占主导地位的项，例如当 `n` 足够大时，

$n^2 + 3n + 8$ 中决定数量级别的项是 $n^2$
:::

## 插入排序算法的分析

一般来说，算法需要的运行时间 `t`与输入的规模 `n` 同步增长，所以通常把一个程序的运行时间描述成输入规模的函数 $t = f(n)$

::: tip 说明
**输入规模**视情况而定，例如排序或计算离散傅里叶变换，那么量度是输入的项数 `n`。而对于图而言，输入规模可用图中的顶点数和边数来描述。对于研究的每一个问题，都需要指出使用的输入规模量度。

**运行时间**指的执行的基本操作数或步数，因为这样可独立于机器，方便算法分析。
:::

在程序运行中，运行每一行代码需要常量时间（这里包括子程序调用，只是子程序调用需要更大的常量时间而已），注释是不可执行的语句，因此不需要花费时间。对插入排序进行运行总时间统计：

@[code js](../../src/algorithms/sorting/insertion-sort.js)

假定第 `i` 行的程序每次执行需要常量时间，那么每行运行的代价和次数如下表所示：

| 指令序号 | 运行代价 | 运行次数                                 |
|:--------:|:--------:|:-----------------------------------------|
|    15    | $c_{15}$ | n                                        |
|    16    | $c_{16}$ | n                                        |
|    17    | $c_{17}$ | n - 1                                    |
|    19    | $c_{19}$ | n - 1                                    |
|    22    | $c_{22}$ | $\displaystyle\sum_{i=1}^{n-1}t_i$       |
|    23    | $c_{23}$ | $\displaystyle\sum_{i=1}^{n-1}(t_i - 1)$ |
|    24    | $c_{24}$ | $\displaystyle\sum_{i=1}^{n-1}(t_i - 1)$ |
|    27    | $c_{24}$ | n - 1                                    |
|    29    | $c_{29}$ | 1                                        |
------

::: tip 说明
注意循环头的执行次数比循环体多一次，用于判断循环退出条件。图中 $t_i$的表示程序运行在值时 `while` 循环所需要执行的次数，

例如考虑最佳情况，待插入的元素在**循环不变式**中是最大的，那么 `while` 循环只需要执行一次（循环一次都不满足），

如果考虑最坏情况，待插入的元素在**循环不变式**中是最小的，那么运行值时，`while` 循环需要执行次，因此用表示循环不确定的次数。
:::

插入排序算法所需要的总代价如下：

$$
T_n = (c_{15} + c_{16})n + (c_{17} + c_{19} + c_{27})(n - 1) + c_{22}\displaystyle\sum_{i=1}^{n-1}t_i + (c_{23} + c_{24})\displaystyle\sum_{i=1}^{n-1}(t_i - 1) + c_{29}
$$

考虑最佳情况 $t_i = 1$，当时：

$$
T_n = (c_{15} + c_{16})n + (c_{17} + c_{19} + c_{27})(n - 1) + c_{22}(n - 1) + c_{29}   
$$

$$
= (c_{15} + c_{16} + c_{17} + c_{19} + c_{22} + c_{27})n + c_{29} - c_{17} - c_{19} - c_{22} - c_{27}
$$

可以把上述公式表示为：

$$
T_n = an + b
$$

考虑最坏情况 $t_i = j$，当时：

$$
\displaystyle\sum_{i=1}^{n-1}j = \frac {n(n - 1)} 2
$$

$$
\displaystyle\sum_{i=1}^{n-1}j - 1 = \frac {(n - 1)(n - 2)} 2
$$

$$
T_n = (c_{15} + c_{16})n + (c_{17} + c_{19} + c_{27})(n - 1) + c_{22}\frac {n(n - 1)} 2 + (c_{23} + c_{24})\frac {(n - 1)(n - 2)} 2 + c_{29}
$$

可以把上述公式表示为：

$$
T_n = an^2 + bn + c
$$

## 最坏情况分析

在上面的分析中，我们考虑了最佳情况和最坏情况，但是在实际中我们往往更应该考虑最坏情况，理由有以下三点：

- 最坏情况给出了输入规模对应的运行时间上界，可以期望它不会变的更差。
- 最坏情况经常出现。
- 平均情况往往与最坏情况一样差，例如考虑上述插入排序，当时，仍然是的二次函数。

## 增长量级


为了分析算法更容易，我们做出一种更简化的抽象：关注算法运行时间的**增长率**和**正常量级**。所以我们只考虑最重要的项。

以插入排序$T_n = an^2 + bn + c$，为例，最重要项是$an^2$,当`n`很大时，$bn + c$可以忽略不计，两外`a`也变得不重要了，也可以忽略。
所以此例的最重要项是$n^2$，即增长量级为$n^2$

增长量级的用处：比较算法的优劣。如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级，我们通常认为前者比后者更有效。例如，一个$O(n^2)$的算法在最坏情况下比另一个$O(n^3)$的算法运行得更快。